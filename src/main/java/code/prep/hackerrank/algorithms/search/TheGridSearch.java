package code.prep.hackerrank.algorithms.search;

import java.util.Arrays;
import java.util.Scanner;

/**
 * Problem Statement
 * Given a 2D array of digits, try to find the location of a given 2D pattern of digits within it. 
 * For example, consider the following 2D matrix.
 * 		1234567890  
 * 		0987654321  
 * 		1111111111  
 * 		1111111111  
 * 		2222222222  
 * 
 * If we need to look for the following 2D pattern within it:
 * 		876543  
 * 		111111  
 * 		111111
 * 
 * If we scan through the original array, we observe, that 2D pattern begins from the second row and the 
 * third column of the larger grid (the 8 in the second row and third column of the larger grid, is the 
 * top-left corner of the pattern we are searching for).
 * 
 * So, a 2D pattern of digits P is said to be present in a larger grid G, if the latter contains a 
 * contiguous, rectangular 2D grid of digits matching with the pattern P; similar to the example shown 
 * above.
 * 
 * Input Format 
 * The first line contains an integer T, which is the number of tests. T tests follow and the structure 
 * of each test is described below: 
 * 		The first line contains 2 space separated integers R and C indicating the number of rows and 
 * 		columns in the grid G. 
 * 
 * 		This is followed by R lines, each with a string of C digits each; which represent the grid G. 
 * 
 * 		The second line contains 2 tab separated integers r and c indicating the number of rows and 
 * 		columns in the pattern grid P. 
 * 
 * 		This is followed by r lines, each with a string of c digits each; which represent the pattern P.
 * 
 * Constraints 
 * 1<=T<=5 
 * 1<=R,r,C,c<=1000 
 * 1<=r<=R 
 * 1<=c<=C
 * 
 * Test Case Generation 
 * Each individual test has been generated by first specifying the size (R and C) of the large 2D matrix, 
 * and then randomly generating the digits in it. A limited number of digits in the larger matrix may be 
 * changed by the problem setter (no more than 5% of the total number of digits in the marix). So the 
 * larger 2D matrix is almost-random. The pattern matrix has been manually-curated by the problem setter.
 * 
 * Output Format 
 * Display 'YES' or 'NO', depending on whether (or not) you find that the larger grid G contains the 
 * rectangular pattern P. The evaluation will be case sensitive.
 * 
 * Sample Input
 * 2
 * 10 10
 * 7283455864
 * 6731158619
 * 8988242643
 * 3830589324
 * 2229505813
 * 5633845374
 * 6473530293
 * 7053106601
 * 0834282956
 * 4607924137
 * 3 4
 * 9505
 * 3845
 * 3530
 * 15 15
 * 400453592126560
 * 114213133098692
 * 474386082879648
 * 522356951189169
 * 887109450487496
 * 252802633388782
 * 502771484966748
 * 075975207693780
 * 511799789562806
 * 404007454272504
 * 549043809916080
 * 962410809534811
 * 445893523733475
 * 768705303214174
 * 650629270887160
 * 2 2
 * 99
 * 99
 * 
 * Sample Output
 * YES
 * NO
 */

public class TheGridSearch 
{
	private static int[][] subMatrix(int[][] mat, int startR, int endR, int startC, int endC)
	{
		int[][] sub = new int[endR - startR][endC - startC];
		
		for (int subI = 0, matI = startR; matI < endR; ++subI, ++matI)
		{
			for (int subJ = 0, matJ = startC; matJ < endC; ++subJ, ++matJ)
			{
				int tmp = mat[matI][matJ];
				sub[subI][subJ] = tmp;
			}
		}
		
		return sub;
	}
	
	private static boolean samePattern(int[][] mat1, int[][] mat2)
	{
		boolean samePattern = true;
		
		if (mat1 == null && mat2 != null || mat2 == null && mat1 != null)
		{
			samePattern = false;
		}
		else if (mat1.length == mat2.length && mat1[0].length == mat2[0].length)
		{
			loop:
				for (int i = 0; i < mat1.length; ++i)
				{
					for (int j = 0; j < mat1[0].length; ++j)
					{
						if (mat1[i][j] != mat2[i][j])
						{
							samePattern = false;
							break loop;
						}
					}
				}
		}
		else
		{
			samePattern = false;
		}
		
		return samePattern;
	}
	
	private static void containsPattern(int[][] grid, int[][] pattern, int r, int c)
	{
		String  containsPattern = "NO";
		int[][] tmp				= new int[r][c];
		
		loop:
			for (int i = 0; i + r < grid.length; ++i)
			{
				for (int j = 0; j + c< grid[i].length; ++j)
				{
					tmp = subMatrix(grid, i, i + r, j, j + c);
					if (Arrays.deepEquals(pattern, tmp))
					{
						containsPattern = "YES";
						break loop;
					}
				}
			}
		
		System.out.println(containsPattern);
	}
	
	private static void containsPattern1(int[][] grid, int[][] pattern, int r, int c)
	{
		String  containsPattern = "NO";
		int[][] tmp				= new int[r][c];
		
		loop:
			for (int i = 0; i + r < grid.length; ++i)
			{
				for (int j = 0; j + c< grid[i].length; ++j)
				{
					tmp = subMatrix(grid, i, i + r, j, j + c);
					if (samePattern(pattern, tmp))
					{
						containsPattern = "YES";
						break loop;
					}
				}
			}
		
		System.out.println(containsPattern);
	}
	
	public static void main(String[] args)
	{
		int		C, c, i, j, t, R, r;
		String  row;
		int[][] grid, pattern;
		Scanner scanner = new Scanner(System.in);
		
		t = scanner.nextInt();
		
		while (t > 0)
		{
			R    = scanner.nextInt();
			C    = scanner.nextInt();
			grid = new int[R][C];
			
			for (i = 0; i < R; ++i)
			{
				row = scanner.next();
				for (j = 0; j < C; ++j)
				{
					grid[i][j] = Character.getNumericValue(row.charAt(j));	
				}
			}
			
			r       = scanner.nextInt();
			c       = scanner.nextInt();
			pattern = new int[r][c];
			
			for (i = 0; i < r; ++i)
			{
				row = scanner.next();
				for (j = 0; j < c; ++j)
				{
					pattern[i][j] = Character.getNumericValue(row.charAt(j));
				}
			}
			
			long start, end;
			start = System.nanoTime();
			containsPattern(grid, pattern, r, c);
			end   = System.nanoTime() - start;
			System.out.println(end);
			
			start = System.nanoTime();
			containsPattern1(grid, pattern, r, c);
			end   = System.nanoTime() - start;
			System.out.println(end);
			--t;
		}
		
		scanner.close();
	}
}
